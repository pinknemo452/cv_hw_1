# ЛР1 — Фильтр Собеля

**Цель работы:**
Научиться реализовывать простой алгоритм обработки изображений — фильтр Собеля — в двух вариантах (с использованием библиотек и нативно), сравнить быстродействие и оформить отчёт.

---

## Содержание репозитория

* `Sobel.ipynb` — ноутбук с реализацией (OpenCV + нативная реализация на Python), измерением времени и примерами. (Файл загружён: `/mnt/data/Sobel.ipynb`)
* `images/` — примеры входных изображений (положить сюда тестовые изображения)
* `results/` — выходные изображения, графики и скриншоты
* `README.md` — этот файл (инструкции и отчёт)

---

## 1. Теоретическая база

Фильтр Собеля — оператор краёв, приближает градиент интенсивности изображения. Применяется для выделения границ. Основные понятия:

* **Ядра Собеля (горизонтальный и вертикальный):**

  Горизонтальный (Gx):

  ```text
  [-1 0 1
   -2 0 2
   -1 0 1]
  ```

  Вертикальный (Gy):

  ```text
  [-1 -2 -1
    0  0  0
    1  2  1]
  ```

* **Градиент:**

  * Модуль градиента: `G = sqrt(Gx^2 + Gy^2)` или приближённо `|Gx| + |Gy|`.
  * Направление градиента: `theta = arctan2(Gy, Gx)`.

* **Предобработка:**

  * Преобразование в градации серого: `Y = 0.299 R + 0.587 G + 0.114 B`.
  * При необходимости размытие (гауссовский фильтр) для подавления шума.

---

## 2. Описание разработанной системы

### 2.1. Задачи, реализованные в ноутбуке

1. Загрузка изображения и приведение к оттенкам серого.
2. Реализация фильтра Собеля двумя способами:

   * **С использованием OpenCV**: `cv2.Sobel` или `cv2.filter2D` с ядрами Собеля.
   * **Нативная реализация (Python + NumPy)**: реализация свёртки (convolution) вручную (векторизованно при помощи NumPy) с обработкой граничных эффектов (zero padding / replicate).
3. Вычисление модуля градиента и направления.
4. Пороговая обработка / нормализация для визуализации.
5. Измерение быстродействия (время выполнения) для обоих вариантов — повторение выполнения N раз и усреднение.
6. Построение графиков времени выполнения и сохранение результатов.

### 2.2. Принципы работы

* Вход: цветное изображение или уже серое.
* Для корректного сравнения оба варианта используют одну и ту же предобработку и одинаковые входные данные.
* Время измеряется только для участка данных, реализующего ядро фильтрации и подсчёт градиента (без I/O и отрисовки), чтобы сравнение было честным.
* Для нативной реализации применяется векторизованная свёртка (через срезы/строки), либо — для наглядности — реализована функция свёртки в чистом Python (медленный вариант) и в NumPy (ускоренный нативный вариант).

### 2.3. Архитектура ноутбука

Ноутбук разбит на логические блоки:

1. Импорты и конфигурация (путь к изображениям, число повторов для тестов).
2. Вспомогательные функции:

   * `to_gray(image)` — конвертация в серое.
   * `pad_image(image, pad, mode)` — паддинг для нативной свёртки.
   * `convolve2d_numpy(image, kernel)` — векторизованная нативная свёртка.
   * `sobel_opencv(image)` — реализация через OpenCV.
   * `sobel_native(image)` — реализация через нативную свёртку (Gx, Gy → magnitude).
   * `timeit_func(func, *args, repeats=10)` — измерение времени (использует `time.perf_counter`).
3. Примеры запуска на одном/нескольких изображениях.
4. Сбор статистики и построение графиков (matplotlib).
5. Сохранение результатов в `results/`.

---

## 3. Результаты работы и тестирования системы

> **Примечание:** в этом репозитории в ноутбуке `/mnt/data/Sobel.ipynb` содержатся все экспериментальные запуски и сохранённые изображения. Для воспроизведения поместите тестовые изображения в папку `images/` и запустите ноутбук.

### 3.1. Что должно быть в `results/` после запуска ноутбука

* `edge_opencv_<imagename>.png` — результат OpenCV-реализации.
* `edge_native_<imagename>.png` — результат нативной реализации.
* `timings.csv` — таблица с измерениями времени для каждого изображения и метода.
* `timings_plot.png` — график сравнения времени выполнения методов.
* `comparison_<imagename>.png` — картинка с рядом: исходное | OpenCV | native

### 3.2. Как запускать тесты (примеры)

Запустить ноутбук (через JupyterLab / Jupyter Notebook):

```bash
jupyter notebook /mnt/data/Sobel.ipynb
```

Или сохранить небольшие утилиты в отдельный скрипт `run_tests.py` и запускать:

```bash
python run_tests.py --input images/ --out results/ --repeats 20
```

`run_tests.py` (примерный алгоритм):

1. Для каждого файла в `images/`:

   * Загрузить, привести к grayscale.
   * Запустить `sobel_opencv` `repeats` раз, измерить среднее время.
   * Запустить `sobel_native` `repeats` раз, измерить среднее время.
   * Сохранить результаты и записать времена в `timings.csv`.
2. Построить график `timings_plot.png` (оси: изображения или размеры vs время).

### 3.3. Ожидаемые закономерности

* Реализация на OpenCV (которая использует оптимизированный C/C++ код) будет значительно быстрее нативной Python-реализации, особенно на больших изображениях.
* Векторизованная нативная реализация через NumPy (`convolve2d_numpy`) покажет лучшую производительность, чем чисто-питоновские циклы, но всё равно уступит OpenCV.
* Разница во времени будет увеличиваться с ростом размера изображения.

---

## 4. Выводы по работе (шаблон)

* В ходе лабораторной работы получен опыт реализации оператора Собеля двумя способами: библиотечным и нативным.
* Эксперименты показали, что реализация на OpenCV быстрее на N% (вставьте реальное значение после запуска тестов) по сравнению с нативной реализацией.
* Для реальных задач следует использовать оптимизированные библиотеки (OpenCV) либо компилируемые расширения (Cython, Numba) при необходимости нативной логики.
* Нативная реализация полезна для понимания алгоритма и образовательных целей; при этом её можно оптимизировать (векторизация, многопоточность).

---

## 5. Использованные источники

* Richard Szeliski. *Computer Vision: Algorithms and Applications* — разделы по выделению границ.
* Документация OpenCV: описание `cv2.Sobel` и `cv2.filter2D`.
* Wikipedia: Sobel operator.
* Примеры и учебные материалы по реализации свёртки в NumPy.

---

## Примечания по оформлению на GitHub

1. В корень репозитория положите `Sobel.ipynb`, `README.md`, папки `images/` и `results/`.
2. В `README.md` дайте ссылку на ноутбук: `/mnt/data/Sobel.ipynb` (в GitHub это будет относительная ссылка `./Sobel.ipynb`).
3. В ноутбуке оформите Markdown-блоки: цель, теоретическая основа, экспериментальная часть, результаты и выводы — чтобы преподаватель мог открыть репозиторий и сразу увидеть отчёт.

---

Если нужно, могу:

* Сгенерировать автоматически готовые графики и вставить их в `results/`, если вы разрешите запустить тесты (или пришлёте логи/тайминги).
* Преобразовать этот файл в `README.md` и добавить простую утилиту `run_tests.py`.
* Подготовить PDF-версию отчёта.

Спасибо — я подготовил отчет и разместил его как документ в канвасе. Напишите, если хотите, чтобы я добавил реальные скриншоты/графики, используя ваш ноутбук и изображения.
